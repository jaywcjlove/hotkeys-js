{"version":3,"file":"hotkeys-js.js","sources":["../src/utils.ts","../src/var.ts","../src/index.ts"],"sourcesContent":["const isff: boolean =\n  typeof navigator !== \"undefined\"\n    ? navigator.userAgent.toLowerCase().indexOf(\"firefox\") > 0\n    : false;\n\n/** Bind event */\nfunction addEvent(\n  object: HTMLElement | Document | Window,\n  event: string,\n  method: EventListenerOrEventListenerObject,\n  useCapture?: boolean\n): void {\n  if (object.addEventListener) {\n    object.addEventListener(event, method, useCapture);\n    // @ts-expect-error - attachEvent is only available on IE\n  } else if (object.attachEvent) {\n    // @ts-expect-error - attachEvent is only available on IE\n    object.attachEvent(`on${event}`, method);\n  }\n}\n\nfunction removeEvent(\n  object: HTMLElement | Document | Window | null,\n  event: string,\n  method: EventListenerOrEventListenerObject,\n  useCapture?: boolean\n): void {\n  if (!object) return;\n  if (object.removeEventListener) {\n    object.removeEventListener(event, method, useCapture);\n    // @ts-expect-error - removeEvent is only available on IE\n  } else if (object.detachEvent) {\n    // @ts-expect-error - detachEvent is only available on IE\n    object.detachEvent(`on${event}`, method);\n  }\n}\n\n/** Convert modifier keys to their corresponding key codes */\nfunction getMods(modifier: Record<string, number>, key: string[]): number[] {\n  const mods = key.slice(0, key.length - 1);\n  for (let i = 0; i < mods.length; i++)\n    mods[i] = modifier[mods[i].toLowerCase()] as any;\n  return mods as any;\n}\n\n/** Process the input key string and convert it to an array */\nfunction getKeys(key: string | undefined): string[] {\n  if (typeof key !== \"string\") key = \"\";\n  key = key.replace(/\\s/g, \"\"); // Match any whitespace character, including spaces, tabs, form feeds, etc.\n  const keys = key.split(\",\"); // Allow multiple shortcuts separated by ','\n  let index = keys.lastIndexOf(\"\");\n\n  // Shortcut may include ',' — special handling needed\n  for (; index >= 0; ) {\n    keys[index - 1] += \",\";\n    keys.splice(index, 1);\n    index = keys.lastIndexOf(\"\");\n  }\n\n  return keys;\n}\n\n/** Compare arrays of modifier keys */\nfunction compareArray(a1: number[], a2: number[]): boolean {\n  const arr1 = a1.length >= a2.length ? a1 : a2;\n  const arr2 = a1.length >= a2.length ? a2 : a1;\n  let isIndex = true;\n\n  for (let i = 0; i < arr1.length; i++) {\n    if (arr2.indexOf(arr1[i]) === -1) isIndex = false;\n  }\n  return isIndex;\n}\n\nexport { isff, getMods, getKeys, addEvent, removeEvent, compareArray };\n","import { isff } from './utils';\n\n// Special Keys\nconst _keyMap: Record<string, number> = {\n  backspace: 8,\n  '⌫': 8,\n  tab: 9,\n  clear: 12,\n  enter: 13,\n  '↩': 13,\n  return: 13,\n  esc: 27,\n  escape: 27,\n  space: 32,\n  left: 37,\n  up: 38,\n  right: 39,\n  down: 40,\n  /// https://w3c.github.io/uievents/#events-keyboard-key-location\n  arrowup: 38,\n  arrowdown: 40,\n  arrowleft: 37,\n  arrowright: 39,\n  del: 46,\n  delete: 46,\n  ins: 45,\n  insert: 45,\n  home: 36,\n  end: 35,\n  pageup: 33,\n  pagedown: 34,\n  capslock: 20,\n  num_0: 96,\n  num_1: 97,\n  num_2: 98,\n  num_3: 99,\n  num_4: 100,\n  num_5: 101,\n  num_6: 102,\n  num_7: 103,\n  num_8: 104,\n  num_9: 105,\n  num_multiply: 106,\n  num_add: 107,\n  num_enter: 108,\n  num_subtract: 109,\n  num_decimal: 110,\n  num_divide: 111,\n  '⇪': 20,\n  ',': 188,\n  '.': 190,\n  '/': 191,\n  '`': 192,\n  '-': isff ? 173 : 189,\n  '=': isff ? 61 : 187,\n  ';': isff ? 59 : 186,\n  '\\'': 222,\n  '{': 219,\n  '}': 221,\n  '[': 219,\n  ']': 221,\n  '\\\\': 220,\n};\n\n// Modifier Keys\nconst _modifier: Record<string, number> = {\n  // shiftKey\n  '⇧': 16,\n  shift: 16,\n  // altKey\n  '⌥': 18,\n  alt: 18,\n  option: 18,\n  // ctrlKey\n  '⌃': 17,\n  ctrl: 17,\n  control: 17,\n  // metaKey\n  '⌘': 91,\n  cmd: 91,\n  meta: 91,\n  command: 91,\n};\n\nconst modifierMap: Record<string | number, number | string> = {\n  16: 'shiftKey',\n  18: 'altKey',\n  17: 'ctrlKey',\n  91: 'metaKey',\n\n  shiftKey: 16,\n  ctrlKey: 17,\n  altKey: 18,\n  metaKey: 91,\n};\n\nconst _mods: Record<number, boolean> = {\n  16: false,\n  18: false,\n  17: false,\n  91: false,\n};\n\nexport interface Handler {\n  keyup: boolean;\n  keydown: boolean;\n  scope: string;\n  mods: number[];\n  shortcut: string;\n  method: KeyHandler;\n  key: string;\n  splitKey: string;\n  element: HTMLElement | Document;\n  keys?: number[];\n}\n\nexport interface KeyHandler {\n  (keyboardEvent: KeyboardEvent, hotkeysEvent: Handler): void | boolean;\n}\n\nconst _handlers: Record<string | number, Handler[]> = {};\n\n// F1~F12 special key\nfor (let k = 1; k < 20; k++) {\n  _keyMap[`f${k}`] = 111 + k;\n}\n\nexport { _keyMap, _modifier, modifierMap, _mods, _handlers };\n","import { addEvent, removeEvent, getMods, getKeys, compareArray } from \"./utils\";\nimport {\n  _keyMap,\n  _modifier,\n  modifierMap,\n  _mods,\n  _handlers,\n  Handler,\n  KeyHandler,\n} from \"./var\";\n\n/** Record the pressed keys */\nlet _downKeys: number[] = [];\n/** Whether the window has already listened to the focus event */\nlet winListendFocus: { listener: EventListener; capture: boolean } | null =\n  null;\n/** Default hotkey scope */\nlet _scope: string = \"all\";\n/** Map to record elements with bound events */\nconst elementEventMap = new Map<\n  HTMLElement | Document,\n  {\n    keydownListener: EventListener;\n    keyupListenr: EventListener;\n    capture: boolean;\n  }\n>();\n\n/** Return key code */\nconst code = (x: string): number =>\n  _keyMap[x.toLowerCase()] ||\n  _modifier[x.toLowerCase()] ||\n  x.toUpperCase().charCodeAt(0);\n\nconst getKey = (x: number): string | undefined =>\n  Object.keys(_keyMap).find((k) => _keyMap[k] === x);\nconst getModifier = (x: number): string | undefined =>\n  Object.keys(_modifier).find((k) => _modifier[k] === x);\n\n/** Set or get the current scope (defaults to 'all') */\nfunction setScope(scope: string): void {\n  _scope = scope || \"all\";\n}\n/** Get the current scope */\nfunction getScope(): string {\n  return _scope || \"all\";\n}\n/** Get the key codes of the currently pressed keys */\nfunction getPressedKeyCodes(): number[] {\n  return _downKeys.slice(0);\n}\n\nfunction getPressedKeyString(): string[] {\n  return _downKeys.map(\n    (c) => getKey(c) || getModifier(c) || String.fromCharCode(c)\n  );\n}\n\ninterface KeyCodeInfo {\n  scope: string;\n  shortcut: string;\n  mods: number[];\n  keys: number[];\n}\n\nfunction getAllKeyCodes(): KeyCodeInfo[] {\n  const result: KeyCodeInfo[] = [];\n  Object.keys(_handlers).forEach((k) => {\n    _handlers[k].forEach(({ key, scope, mods, shortcut }) => {\n      result.push({\n        scope,\n        shortcut,\n        mods,\n        keys: key.split(\"+\").map((v) => code(v)),\n      });\n    });\n  });\n  return result;\n}\n\n/** hotkey is effective only when filter return true */\nfunction filter(event: KeyboardEvent): boolean {\n  const target = (event.target || event.srcElement) as HTMLElement;\n  const { tagName } = target;\n  let flag = true;\n  const isInput =\n    tagName === \"INPUT\" &&\n    ![\n      \"checkbox\",\n      \"radio\",\n      \"range\",\n      \"button\",\n      \"file\",\n      \"reset\",\n      \"submit\",\n      \"color\",\n    ].includes((target as HTMLInputElement).type);\n  // ignore: isContentEditable === 'true', <input> and <textarea> when readOnly state is false, <select>\n  if (\n    (target as any).isContentEditable ||\n    ((isInput || tagName === \"TEXTAREA\" || tagName === \"SELECT\") &&\n      !(target as HTMLInputElement | HTMLTextAreaElement).readOnly)\n  ) {\n    flag = false;\n  }\n  return flag;\n}\n\n/** Determine whether the pressed key matches a specific key, returns true or false */\nfunction isPressed(keyCode: number | string): boolean {\n  if (typeof keyCode === \"string\") {\n    keyCode = code(keyCode); // Convert to key code\n  }\n  return _downKeys.indexOf(keyCode) !== -1;\n}\n\n/** Loop through and delete all handlers with the specified scope */\nfunction deleteScope(scope?: string, newScope?: string): void {\n  let handlers: Handler[];\n  let i: number;\n\n  // If no scope is specified, get the current scope\n  if (!scope) scope = getScope();\n\n  for (const key in _handlers) {\n    if (Object.prototype.hasOwnProperty.call(_handlers, key)) {\n      handlers = _handlers[key];\n      for (i = 0; i < handlers.length; ) {\n        if (handlers[i].scope === scope) {\n          const deleteItems = handlers.splice(i, 1);\n          deleteItems.forEach(({ element }) => removeKeyEvent(element));\n        } else {\n          i++;\n        }\n      }\n    }\n  }\n\n  // If the current scope has been deleted, reset the scope to 'all'\n  if (getScope() === scope) setScope(newScope || \"all\");\n}\n\n/** Clear modifier keys */\nfunction clearModifier(event: KeyboardEvent): void {\n  let key = event.keyCode || event.which || (event as any).charCode;\n  if (event.key && event.key.toLowerCase() === \"capslock\") {\n    // Ensure that when capturing keystrokes in modern browsers,\n    // uppercase and lowercase letters (such as R and r) return the same key value.\n    // https://github.com/jaywcjlove/hotkeys-js/pull/514\n    // https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key\n    key = code(event.key);\n  }\n  const i = _downKeys.indexOf(key);\n\n  // Remove the pressed key from the list\n  if (i >= 0) {\n    _downKeys.splice(i, 1);\n  }\n  // Special handling for the command key: fix the issue where keyup only triggers once for command combos\n  if (event.key && event.key.toLowerCase() === \"meta\") {\n    _downKeys.splice(0, _downKeys.length);\n  }\n\n  // Clear modifier keys: shiftKey, altKey, ctrlKey, (command || metaKey)\n  if (key === 93 || key === 224) key = 91;\n  if (key in _mods) {\n    _mods[key] = false;\n\n    // Reset the modifier key status to false\n    for (const k in _modifier)\n      if (_modifier[k] === key) (hotkeys as any)[k] = false;\n  }\n}\n\ninterface UnbindInfo {\n  key: string;\n  scope?: string;\n  method?: KeyHandler;\n  splitKey?: string;\n}\n\nfunction unbind(\n  keysInfo?: string | UnbindInfo | UnbindInfo[],\n  ...args: any[]\n): void {\n  // unbind(), unbind all keys\n  if (typeof keysInfo === \"undefined\") {\n    Object.keys(_handlers).forEach((key) => {\n      if (Array.isArray(_handlers[key])) {\n        _handlers[key].forEach((info) => eachUnbind(info));\n      }\n      delete _handlers[key];\n    });\n    removeKeyEvent(null);\n  } else if (Array.isArray(keysInfo)) {\n    // support like : unbind([{key: 'ctrl+a', scope: 's1'}, {key: 'ctrl-a', scope: 's2', splitKey: '-'}])\n    keysInfo.forEach((info) => {\n      if (info.key) eachUnbind(info);\n    });\n  } else if (typeof keysInfo === \"object\") {\n    // support like unbind({key: 'ctrl+a, ctrl+b', scope:'abc'})\n    if (keysInfo.key) eachUnbind(keysInfo);\n  } else if (typeof keysInfo === \"string\") {\n    // support old method\n    let [scope, method] = args;\n    if (typeof scope === \"function\") {\n      method = scope;\n      scope = \"\";\n    }\n    eachUnbind({\n      key: keysInfo,\n      scope,\n      method,\n      splitKey: \"+\",\n    });\n  }\n}\n\n/** Unbind hotkeys for a specific scope */\nconst eachUnbind = ({\n  key,\n  scope,\n  method,\n  splitKey = \"+\",\n}: UnbindInfo): void => {\n  const multipleKeys = getKeys(key);\n  multipleKeys.forEach((originKey) => {\n    const unbindKeys = originKey.split(splitKey);\n    const len = unbindKeys.length;\n    const lastKey = unbindKeys[len - 1];\n    const keyCode = lastKey === \"*\" ? \"*\" : code(lastKey);\n    if (!_handlers[keyCode]) return;\n    // If scope is not provided, get the current scope\n    if (!scope) scope = getScope();\n    const mods = len > 1 ? getMods(_modifier, unbindKeys) : [];\n    const unbindElements: (HTMLElement | Document)[] = [];\n    _handlers[keyCode] = _handlers[keyCode].filter((record) => {\n      // Check if the method matches; if method is provided, must be equal to unbind\n      const isMatchingMethod = method ? record.method === method : true;\n      const isUnbind =\n        isMatchingMethod &&\n        record.scope === scope &&\n        compareArray(record.mods, mods);\n      if (isUnbind) unbindElements.push(record.element);\n      return !isUnbind;\n    });\n    unbindElements.forEach((element) => removeKeyEvent(element));\n  });\n};\n\n/** Handle the callback function for the corresponding hotkey */\nfunction eventHandler(\n  event: KeyboardEvent,\n  handler: Handler,\n  scope: string,\n  element: HTMLElement | Document\n): void {\n  if (handler.element !== element) {\n    return;\n  }\n  let modifiersMatch: boolean;\n\n  // Check if it is within the current scope\n  if (handler.scope === scope || handler.scope === \"all\") {\n    // Check whether modifier keys match (returns true if they do)\n    modifiersMatch = handler.mods.length > 0;\n\n    for (const y in _mods) {\n      if (Object.prototype.hasOwnProperty.call(_mods, y)) {\n        if (\n          (!_mods[y] && handler.mods.indexOf(+y) > -1) ||\n          (_mods[y] && handler.mods.indexOf(+y) === -1)\n        ) {\n          modifiersMatch = false;\n        }\n      }\n    }\n\n    // Call the handler function; ignore if it's only a modifier key\n    if (\n      (handler.mods.length === 0 &&\n        !_mods[16] &&\n        !_mods[18] &&\n        !_mods[17] &&\n        !_mods[91]) ||\n      modifiersMatch ||\n      handler.shortcut === \"*\"\n    ) {\n      handler.keys = [];\n      handler.keys = handler.keys.concat(_downKeys);\n      if (handler.method(event, handler) === false) {\n        if (event.preventDefault) event.preventDefault();\n        else (event as any).returnValue = false;\n        if (event.stopPropagation) event.stopPropagation();\n        if ((event as any).cancelBubble) (event as any).cancelBubble = true;\n      }\n    }\n  }\n}\n\n/** Handle the keydown event */\nfunction dispatch(\n  this: any,\n  event: KeyboardEvent,\n  element: HTMLElement | Document\n): void {\n  const asterisk = _handlers[\"*\"];\n  let key = event.keyCode || event.which || (event as any).charCode;\n\n  // LAYOUT INDEPENDENCE: Convert event.code to keyCode for layout-independent hotkeys\n  // This makes 'ctrl+a' work on Russian/German/any keyboard layout\n  if (event.code) {\n    const codeMap = {\n      KeyA: 65,\n      KeyB: 66,\n      KeyC: 67,\n      KeyD: 68,\n      KeyE: 69,\n      KeyF: 70,\n      KeyG: 71,\n      KeyH: 72,\n      KeyI: 73,\n      KeyJ: 74,\n      KeyK: 75,\n      KeyL: 76,\n      KeyM: 77,\n      KeyN: 78,\n      KeyO: 79,\n      KeyP: 80,\n      KeyQ: 81,\n      KeyR: 82,\n      KeyS: 83,\n      KeyT: 84,\n      KeyU: 85,\n      KeyV: 86,\n      KeyW: 87,\n      KeyX: 88,\n      KeyY: 89,\n      KeyZ: 90,\n    };\n    if (codeMap[event.code as keyof typeof codeMap]) {\n      key = codeMap[event.code as keyof typeof codeMap];\n    }\n  }\n\n  // Ensure that when capturing keystrokes in modern browsers,\n  // uppercase and lowercase letters (such as R and r) return the same key value.\n  // https://github.com/jaywcjlove/hotkeys-js/pull/514\n  // https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key\n  // CapsLock key\n  // There's an issue where `keydown` and `keyup` events are not triggered after CapsLock is enabled to activate uppercase.\n  if (event.key && event.key.toLowerCase() === \"capslock\") {\n    return;\n  }\n  // Form control filter: by default, shortcut keys are not triggered in form elements\n  const filterFn = (hotkeys as any).filter || filter;\n  if (!filterFn.call(this, event)) return;\n\n  // In Gecko (Firefox), the command key code is 224; unify it with WebKit (Chrome)\n  // In WebKit, left and right command keys have different codes\n  if (key === 93 || key === 224) key = 91;\n\n  /**\n   * Collect bound keys\n   * If an Input Method Editor is processing key input and the event is keydown, return 229.\n   * https://stackoverflow.com/questions/25043934/is-it-ok-to-ignore-keydown-events-with-keycode-229\n   * http://lists.w3.org/Archives/Public/www-dom/2010JulSep/att-0182/keyCode-spec.html\n   */\n  if (_downKeys.indexOf(key) === -1 && key !== 229) _downKeys.push(key);\n  /**\n   * Jest test cases are required.\n   * ===============================\n   */\n  [\"metaKey\", \"ctrlKey\", \"altKey\", \"shiftKey\"].forEach((keyName) => {\n    const keyNum = (modifierMap as any)[keyName] as number;\n    if ((event as any)[keyName] && _downKeys.indexOf(keyNum) === -1) {\n      _downKeys.push(keyNum);\n    } else if (!(event as any)[keyName] && _downKeys.indexOf(keyNum) > -1) {\n      _downKeys.splice(_downKeys.indexOf(keyNum), 1);\n    } else if (keyName === \"metaKey\" && (event as any)[keyName]) {\n      // If the command key is pressed, clear all non-modifier keys except the current event key.\n      // This is because keyup for non-modifier keys will NEVER be triggered when command is pressed.\n      // This is a known browser limitation.\n      _downKeys = _downKeys.filter((k) => k in modifierMap || k === key);\n    }\n  });\n  /**\n   * -------------------------------\n   */\n  if (key in _mods) {\n    _mods[key] = true;\n    // Register special modifier keys to the `hotkeys` object\n    for (const k in _modifier) {\n      if (Object.prototype.hasOwnProperty.call(_modifier, k)) {\n        const eventKey = (modifierMap as any)[_modifier[k]] as string;\n        (hotkeys as any)[k] = (event as any)[eventKey];\n      }\n    }\n\n    if (!asterisk) return;\n  }\n\n  // Bind the modifier keys in modifierMap to the event\n  for (const e in _mods) {\n    if (Object.prototype.hasOwnProperty.call(_mods, e)) {\n      _mods[e] = (event as any)[(modifierMap as any)[e]];\n    }\n  }\n  /**\n   * https://github.com/jaywcjlove/hotkeys/pull/129\n   * This solves the issue in Firefox on Windows where hotkeys corresponding to special characters would not trigger.\n   * An example of this is ctrl+alt+m on a Swedish keyboard which is used to type μ.\n   * Browser support: https://caniuse.com/#feat=keyboardevent-getmodifierstate\n   */\n  if (\n    event.getModifierState &&\n    !(event.altKey && !event.ctrlKey) &&\n    event.getModifierState(\"AltGraph\")\n  ) {\n    if (_downKeys.indexOf(17) === -1) {\n      _downKeys.push(17);\n    }\n\n    if (_downKeys.indexOf(18) === -1) {\n      _downKeys.push(18);\n    }\n\n    _mods[17] = true;\n    _mods[18] = true;\n  }\n\n  // Get the current scope (defaults to 'all')\n  const scope = getScope();\n  // Handle any hotkeys registered as '*'\n  if (asterisk) {\n    for (let i = 0; i < asterisk.length; i++) {\n      if (\n        asterisk[i].scope === scope &&\n        ((event.type === \"keydown\" && asterisk[i].keydown) ||\n          (event.type === \"keyup\" && asterisk[i].keyup))\n      ) {\n        eventHandler(event, asterisk[i], scope, element);\n      }\n    }\n  }\n  // If the key is not registered, return\n  if (!(key in _handlers)) return;\n\n  const handlerKey = _handlers[key];\n  const keyLen = handlerKey.length;\n  for (let i = 0; i < keyLen; i++) {\n    if (\n      (event.type === \"keydown\" && handlerKey[i].keydown) ||\n      (event.type === \"keyup\" && handlerKey[i].keyup)\n    ) {\n      if (handlerKey[i].key) {\n        const record = handlerKey[i];\n        const { splitKey } = record;\n        const keyShortcut = record.key.split(splitKey);\n        const _downKeysCurrent: number[] = []; // Store the current key codes\n        for (let a = 0; a < keyShortcut.length; a++) {\n          _downKeysCurrent.push(code(keyShortcut[a]));\n        }\n        if (_downKeysCurrent.sort().join(\"\") === _downKeys.sort().join(\"\")) {\n          // Match found, call the handler\n          eventHandler(event, record, scope, element);\n        }\n      }\n    }\n  }\n}\n\ninterface HotkeysOptions {\n  scope?: string;\n  element?: HTMLElement | Document;\n  keyup?: boolean;\n  keydown?: boolean;\n  capture?: boolean;\n  splitKey?: string;\n  single?: boolean;\n}\n\ninterface HotkeysInterface {\n  (key: string, method: KeyHandler): void;\n  (key: string, scope: string, method: KeyHandler): void;\n  (key: string, option: HotkeysOptions, method: KeyHandler): void;\n\n  shift?: boolean;\n  ctrl?: boolean;\n  alt?: boolean;\n  option?: boolean;\n  control?: boolean;\n  cmd?: boolean;\n  command?: boolean;\n\n  setScope: typeof setScope;\n  getScope: typeof getScope;\n  deleteScope: typeof deleteScope;\n  getPressedKeyCodes: typeof getPressedKeyCodes;\n  getPressedKeyString: typeof getPressedKeyString;\n  getAllKeyCodes: typeof getAllKeyCodes;\n  isPressed: typeof isPressed;\n  filter: typeof filter;\n  trigger: typeof trigger;\n  unbind: typeof unbind;\n  noConflict?: (deep?: boolean) => HotkeysInterface;\n  keyMap: Record<string, number>;\n  modifier: Record<string, number>;\n  modifierMap: Record<string | number, number | string>;\n}\n\nfunction hotkeys(\n  key: string,\n  option?: string | HotkeysOptions | KeyHandler,\n  method?: KeyHandler\n): void {\n  _downKeys = [];\n  /** List of hotkeys to handle */\n  const keys = getKeys(key);\n  let mods: number[] = [];\n  /** Default scope is 'all', meaning effective in all scopes */\n  let scope: string = \"all\";\n  /** Element to which the hotkey events are bound */\n  let element: HTMLElement | Document = document;\n  let i = 0;\n  let keyup = false;\n  let keydown = true;\n  let splitKey = \"+\";\n  let capture = false;\n  /** Allow only a single callback */\n  let single = false;\n\n  // Determine if the second argument is a function (no options provided)\n  if (method === undefined && typeof option === \"function\") {\n    method = option;\n  }\n\n  // Parse options object\n  if (Object.prototype.toString.call(option) === \"[object Object]\") {\n    const opts = option as HotkeysOptions;\n    if (opts.scope) scope = opts.scope; // Set scope\n    if (opts.element) element = opts.element; // Set binding element\n    if (opts.keyup) keyup = opts.keyup;\n    if (opts.keydown !== undefined) keydown = opts.keydown;\n    if (opts.capture !== undefined) capture = opts.capture;\n    if (typeof opts.splitKey === \"string\") splitKey = opts.splitKey;\n    if (opts.single === true) single = true;\n  }\n\n  if (typeof option === \"string\") scope = option;\n\n  // If only one callback is allowed, unbind the existing one first\n  if (single) unbind(key, scope);\n\n  // Handle each hotkey\n  for (; i < keys.length; i++) {\n    const currentKey = keys[i].split(splitKey); // Split into individual keys\n    mods = [];\n\n    // If it's a combination, extract modifier keys\n    if (currentKey.length > 1) mods = getMods(_modifier, currentKey);\n\n    // Convert non-modifier key to key code\n    let finalKey: string | number = currentKey[currentKey.length - 1];\n    finalKey = finalKey === \"*\" ? \"*\" : code(finalKey); // '*' means match all hotkeys\n\n    // Initialize handler array if this key has no handlers yet\n    if (!(finalKey in _handlers)) _handlers[finalKey] = [];\n\n    _handlers[finalKey].push({\n      keyup,\n      keydown,\n      scope,\n      mods,\n      shortcut: keys[i],\n      method: method!,\n      key: keys[i],\n      splitKey,\n      element,\n    });\n  }\n  // Register hotkey event listeners on the global document\n  if (typeof element !== \"undefined\" && typeof window !== \"undefined\") {\n    if (!elementEventMap.has(element)) {\n      const keydownListener = (event: Event = (window as any).event) =>\n        dispatch(event as KeyboardEvent, element);\n      const keyupListenr = (event: Event = (window as any).event) => {\n        dispatch(event as KeyboardEvent, element);\n        clearModifier(event as KeyboardEvent);\n      };\n      elementEventMap.set(element, { keydownListener, keyupListenr, capture });\n      addEvent(element, \"keydown\", keydownListener, capture);\n      addEvent(element, \"keyup\", keyupListenr, capture);\n    }\n    // Register focus event listener once to clear pressed keys on window focus\n    if (!winListendFocus) {\n      const listener = () => {\n        _downKeys = [];\n      };\n      winListendFocus = { listener, capture };\n      addEvent(window, \"focus\", listener, capture);\n    }\n  }\n}\n\nfunction trigger(shortcut: string, scope: string = \"all\"): void {\n  Object.keys(_handlers).forEach((key) => {\n    const dataList = _handlers[key].filter(\n      (item) => item.scope === scope && item.shortcut === shortcut\n    );\n    dataList.forEach((data) => {\n      if (data && data.method) {\n        data.method({} as KeyboardEvent, data);\n      }\n    });\n  });\n}\n\n/** Clean up event listeners. After unbinding, check whether the element still has any hotkeys bound. If not, remove its event listeners. */\nfunction removeKeyEvent(element: HTMLElement | Document | null): void {\n  const values = Object.values(_handlers).flat();\n  const findindex = values.findIndex(({ element: el }) => el === element);\n\n  if (findindex < 0 && element) {\n    const { keydownListener, keyupListenr, capture } =\n      elementEventMap.get(element) || ({} as any);\n    if (keydownListener && keyupListenr) {\n      removeEvent(element, \"keyup\", keyupListenr, capture);\n      removeEvent(element, \"keydown\", keydownListener, capture);\n      elementEventMap.delete(element);\n    }\n  }\n\n  if (values.length <= 0 || elementEventMap.size <= 0) {\n    // Remove all event listeners from all elements\n    const eventKeys = Array.from(elementEventMap.keys());\n    eventKeys.forEach((el) => {\n      const { keydownListener, keyupListenr, capture } =\n        elementEventMap.get(el) || ({} as any);\n      if (keydownListener && keyupListenr) {\n        removeEvent(el, \"keyup\", keyupListenr, capture);\n        removeEvent(el, \"keydown\", keydownListener, capture);\n        elementEventMap.delete(el);\n      }\n    });\n    // Clear the elementEventMap\n    elementEventMap.clear();\n    // Clear all handlers\n    Object.keys(_handlers).forEach((key) => delete _handlers[key]);\n    // Remove the global window focus event listener\n    if (winListendFocus) {\n      const { listener, capture } = winListendFocus;\n      removeEvent(window, \"focus\", listener, capture);\n      winListendFocus = null;\n    }\n  }\n}\n\nconst _api = {\n  getPressedKeyString,\n  setScope,\n  getScope,\n  deleteScope,\n  getPressedKeyCodes,\n  getAllKeyCodes,\n  isPressed,\n  filter,\n  trigger,\n  unbind,\n  keyMap: _keyMap,\n  modifier: _modifier,\n  modifierMap,\n};\n\nfor (const a in _api) {\n  if (Object.prototype.hasOwnProperty.call(_api, a)) {\n    (hotkeys as any)[a] = (_api as any)[a];\n  }\n}\n\nif (typeof window !== \"undefined\") {\n  const _hotkeys = (window as any).hotkeys;\n  (hotkeys as HotkeysInterface).noConflict = (deep?: boolean) => {\n    if (deep && (window as any).hotkeys === hotkeys) {\n      (window as any).hotkeys = _hotkeys;\n    }\n    return hotkeys as HotkeysInterface;\n  };\n  (window as any).hotkeys = hotkeys;\n}\n\nexport default hotkeys as HotkeysInterface;\nexport type { KeyHandler, Handler as HotkeysHandler };\n"],"names":["isff","addEvent","object","event","method","useCapture","removeEvent","getMods","modifier","key","mods","getKeys","keys","index","compareArray","a1","a2","arr1","arr2","isIndex","i","_keyMap","_modifier","modifierMap","_mods","_handlers","k","_downKeys","winListendFocus","_scope","elementEventMap","code","x","getKey","getModifier","setScope","scope","getScope","getPressedKeyCodes","getPressedKeyString","c","getAllKeyCodes","result","shortcut","v","filter","target","tagName","flag","isInput","isPressed","keyCode","deleteScope","newScope","handlers","element","removeKeyEvent","clearModifier","hotkeys","unbind","keysInfo","args","info","eachUnbind","splitKey","originKey","unbindKeys","len","lastKey","unbindElements","record","isUnbind","eventHandler","handler","modifiersMatch","y","dispatch","asterisk","codeMap","keyName","keyNum","eventKey","e","handlerKey","keyLen","keyShortcut","_downKeysCurrent","a","option","keyup","keydown","capture","single","opts","currentKey","finalKey","keydownListener","keyupListenr","listener","trigger","item","data","values","el","_api","_hotkeys","deep"],"mappings":";;;;;;;;AAAA,MAAMA,IACJ,OAAO,aAAc,cACjB,UAAU,UAAU,YAAA,EAAc,QAAQ,SAAS,IAAI,IACvD;AAGN,SAASC,EACPC,GACAC,GACAC,GACAC,GACM;AACN,EAAIH,EAAO,mBACFA,EAAA,iBAAiBC,GAAOC,GAAQC,CAAU,IAExCH,EAAO,eAEhBA,EAAO,YAAY,KAAKC,CAAK,IAAIC,CAAM;AAE3C;AAEA,SAASE,EACPJ,GACAC,GACAC,GACAC,GACM;AACN,EAAKH,MACDA,EAAO,sBACFA,EAAA,oBAAoBC,GAAOC,GAAQC,CAAU,IAE3CH,EAAO,eAEhBA,EAAO,YAAY,KAAKC,CAAK,IAAIC,CAAM;AAE3C;AAGA,SAASG,EAAQC,GAAkCC,GAAyB;AAC1E,QAAMC,IAAOD,EAAI,MAAM,GAAGA,EAAI,SAAS,CAAC;AACxC,WAAS,IAAI,GAAG,IAAIC,EAAK,QAAQ;AAC/B,IAAAA,EAAK,CAAC,IAAIF,EAASE,EAAK,CAAC,EAAE,aAAa;AACnC,SAAAA;AACT;AAGA,SAASC,EAAQF,GAAmC;AAC9C,EAAA,OAAOA,KAAQ,aAAgBA,IAAA,KAC7BA,IAAAA,EAAI,QAAQ,OAAO,EAAE;AACrB,QAAAG,IAAOH,EAAI,MAAM,GAAG;AACtB,MAAAI,IAAQD,EAAK,YAAY,EAAE;AAG/B,SAAOC,KAAS;AACT,IAAAD,EAAAC,IAAQ,CAAC,KAAK,KACdD,EAAA,OAAOC,GAAO,CAAC,GACZA,IAAAD,EAAK,YAAY,EAAE;AAGtB,SAAAA;AACT;AAGA,SAASE,EAAaC,GAAcC,GAAuB;AACzD,QAAMC,IAAOF,EAAG,UAAUC,EAAG,SAASD,IAAKC,GACrCE,IAAOH,EAAG,UAAUC,EAAG,SAASA,IAAKD;AAC3C,MAAII,IAAU;AAEd,WAASC,IAAI,GAAGA,IAAIH,EAAK,QAAQG;AAC/B,IAAIF,EAAK,QAAQD,EAAKG,CAAC,CAAC,MAAM,OAAcD,IAAA;AAEvC,SAAAA;AACT;ACrEA,MAAME,IAAkC;AAAA,EACtC,WAAW;AAAA,EACX,KAAK;AAAA,EACL,KAAK;AAAA,EACL,OAAO;AAAA,EACP,OAAO;AAAA,EACP,KAAK;AAAA,EACL,QAAQ;AAAA,EACR,KAAK;AAAA,EACL,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,MAAM;AAAA,EACN,IAAI;AAAA,EACJ,OAAO;AAAA,EACP,MAAM;AAAA;AAAA,EAEN,SAAS;AAAA,EACT,WAAW;AAAA,EACX,WAAW;AAAA,EACX,YAAY;AAAA,EACZ,KAAK;AAAA,EACL,QAAQ;AAAA,EACR,KAAK;AAAA,EACL,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,KAAK;AAAA,EACL,QAAQ;AAAA,EACR,UAAU;AAAA,EACV,UAAU;AAAA,EACV,OAAO;AAAA,EACP,OAAO;AAAA,EACP,OAAO;AAAA,EACP,OAAO;AAAA,EACP,OAAO;AAAA,EACP,OAAO;AAAA,EACP,OAAO;AAAA,EACP,OAAO;AAAA,EACP,OAAO;AAAA,EACP,OAAO;AAAA,EACP,cAAc;AAAA,EACd,SAAS;AAAA,EACT,WAAW;AAAA,EACX,cAAc;AAAA,EACd,aAAa;AAAA,EACb,YAAY;AAAA,EACZ,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAKrB,IAAO,MAAM;AAAA,EAClB,KAAKA,IAAO,KAAK;AAAA,EACjB,KAAKA,IAAO,KAAK;AAAA,EACjB,KAAM;AAAA,EACN,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAK;AAAA,EACL,MAAM;AACR,GAGMsB,IAAoC;AAAA;AAAA,EAExC,KAAK;AAAA,EACL,OAAO;AAAA;AAAA,EAEP,KAAK;AAAA,EACL,KAAK;AAAA,EACL,QAAQ;AAAA;AAAA,EAER,KAAK;AAAA,EACL,MAAM;AAAA,EACN,SAAS;AAAA;AAAA,EAET,KAAK;AAAA,EACL,KAAK;AAAA,EACL,MAAM;AAAA,EACN,SAAS;AACX,GAEMC,IAAwD;AAAA,EAC5D,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,IAAI;AAAA,EAEJ,UAAU;AAAA,EACV,SAAS;AAAA,EACT,QAAQ;AAAA,EACR,SAAS;AACX,GAEMC,IAAiC;AAAA,EACrC,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,IAAI;AACN,GAmBMC,IAAgD,CAAC;AAGvD,SAASC,IAAI,GAAGA,IAAI,IAAIA;AACtB,EAAAL,EAAQ,IAAIK,CAAC,EAAE,IAAI,MAAMA;AChH3B,IAAIC,IAAsB,CAAC,GAEvBC,IACF,MAEEC,IAAiB;AAErB,MAAMC,wBAAsB,IAO1B,GAGIC,IAAO,CAACC,MACZX,EAAQW,EAAE,YAAa,CAAA,KACvBV,EAAUU,EAAE,YAAa,CAAA,KACzBA,EAAE,YAAY,EAAE,WAAW,CAAC,GAExBC,IAAS,CAACD,MACd,OAAO,KAAKX,CAAO,EAAE,KAAK,CAACK,MAAML,EAAQK,CAAC,MAAMM,CAAC,GAC7CE,IAAc,CAACF,MACnB,OAAO,KAAKV,CAAS,EAAE,KAAK,CAACI,MAAMJ,EAAUI,CAAC,MAAMM,CAAC;AAGvD,SAASG,EAASC,GAAqB;AACrC,EAAAP,IAASO,KAAS;AACpB;AAEA,SAASC,IAAmB;AAC1B,SAAOR,KAAU;AACnB;AAEA,SAASS,IAA+B;AAC/B,SAAAX,EAAU,MAAM,CAAC;AAC1B;AAEA,SAASY,IAAgC;AACvC,SAAOZ,EAAU;AAAA,IACf,CAACa,MAAMP,EAAOO,CAAC,KAAKN,EAAYM,CAAC,KAAK,OAAO,aAAaA,CAAC;AAAA,EAC7D;AACF;AASA,SAASC,IAAgC;AACvC,QAAMC,IAAwB,CAAC;AAC/B,gBAAO,KAAKjB,CAAS,EAAE,QAAQ,CAACC,MAAM;AAC1B,IAAAD,EAAAC,CAAC,EAAE,QAAQ,CAAC,EAAE,KAAAjB,GAAK,OAAA2B,GAAO,MAAA1B,GAAM,UAAAiC,QAAe;AACvD,MAAAD,EAAO,KAAK;AAAA,QACV,OAAAN;AAAA,QACA,UAAAO;AAAA,QACA,MAAAjC;AAAA,QACA,MAAMD,EAAI,MAAM,GAAG,EAAE,IAAI,CAACmC,MAAMb,EAAKa,CAAC,CAAC;AAAA,MAAA,CACxC;AAAA,IAAA,CACF;AAAA,EAAA,CACF,GACMF;AACT;AAGA,SAASG,EAAO1C,GAA+B;AACvC,QAAA2C,IAAU3C,EAAM,UAAUA,EAAM,YAChC,EAAE,SAAA4C,MAAYD;AACpB,MAAIE,IAAO;AACL,QAAAC,IACJF,MAAY,WACZ,CAAC;AAAA,IACC;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EAAA,EACA,SAAUD,EAA4B,IAAI;AAG3C,UAAAA,EAAe,sBACdG,KAAWF,MAAY,cAAcA,MAAY,aACjD,CAAED,EAAkD,cAE/CE,IAAA,KAEFA;AACT;AAGA,SAASE,EAAUC,GAAmC;AAChD,SAAA,OAAOA,KAAY,aACrBA,IAAUpB,EAAKoB,CAAO,IAEjBxB,EAAU,QAAQwB,CAAO,MAAM;AACxC;AAGA,SAASC,EAAYhB,GAAgBiB,GAAyB;AACxD,MAAAC,GACA;AAGA,EAAClB,MAAOA,IAAQC,EAAS;AAE7B,aAAW5B,KAAOgB;AAChB,QAAI,OAAO,UAAU,eAAe,KAAKA,GAAWhB,CAAG;AAErD,WADA6C,IAAW7B,EAAUhB,CAAG,GACnB,IAAI,GAAG,IAAI6C,EAAS;AACvB,QAAIA,EAAS,CAAC,EAAE,UAAUlB,IACJkB,EAAS,OAAO,GAAG,CAAC,EAC5B,QAAQ,CAAC,EAAE,SAAAC,QAAcC,EAAeD,CAAO,CAAC,IAE5D;AAOR,EAAIlB,EAAS,MAAMD,KAAOD,EAASkB,KAAY,KAAK;AACtD;AAGA,SAASI,EAActD,GAA4B;AACjD,MAAIM,IAAMN,EAAM,WAAWA,EAAM,SAAUA,EAAc;AACzD,EAAIA,EAAM,OAAOA,EAAM,IAAI,kBAAkB,eAKrCM,IAAAsB,EAAK5B,EAAM,GAAG;AAEhB,QAAAiB,IAAIO,EAAU,QAAQlB,CAAG;AAa/B,MAVIW,KAAK,KACGO,EAAA,OAAOP,GAAG,CAAC,GAGnBjB,EAAM,OAAOA,EAAM,IAAI,kBAAkB,UACjCwB,EAAA,OAAO,GAAGA,EAAU,MAAM,IAIlClB,MAAQ,MAAMA,MAAQ,SAAWA,IAAA,KACjCA,KAAOe,GAAO;AAChB,IAAAA,EAAMf,CAAG,IAAI;AAGb,eAAWiB,KAAKJ;AACd,MAAIA,EAAUI,CAAC,MAAMjB,MAAMiD,EAAgBhC,CAAC,IAAI;AAAA,EAAA;AAEtD;AASA,SAASiC,EACPC,MACGC,GACG;AAEF,MAAA,OAAOD,KAAa;AACtB,WAAO,KAAKnC,CAAS,EAAE,QAAQ,CAAChB,MAAQ;AACtC,MAAI,MAAM,QAAQgB,EAAUhB,CAAG,CAAC,KAC9BgB,EAAUhB,CAAG,EAAE,QAAQ,CAACqD,MAASC,EAAWD,CAAI,CAAC,GAEnD,OAAOrC,EAAUhB,CAAG;AAAA,IAAA,CACrB,GACD+C,EAAe,IAAI;AAAA,WACV,MAAM,QAAQI,CAAQ;AAEtB,IAAAA,EAAA,QAAQ,CAACE,MAAS;AACrB,MAAAA,EAAK,OAAKC,EAAWD,CAAI;AAAA,IAAA,CAC9B;AAAA,WACQ,OAAOF,KAAa;AAEzB,IAAAA,EAAS,OAAKG,EAAWH,CAAQ;AAAA,WAC5B,OAAOA,KAAa,UAAU;AAEnC,QAAA,CAACxB,GAAOhC,CAAM,IAAIyD;AAClB,IAAA,OAAOzB,KAAU,eACVhC,IAAAgC,GACDA,IAAA,KAEC2B,EAAA;AAAA,MACT,KAAKH;AAAA,MACL,OAAAxB;AAAA,MACA,QAAAhC;AAAA,MACA,UAAU;AAAA,IAAA,CACX;AAAA,EAAA;AAEL;AAGA,MAAM2D,IAAa,CAAC;AAAA,EAClB,KAAAtD;AAAA,EACA,OAAA2B;AAAA,EACA,QAAAhC;AAAA,EACA,UAAA4D,IAAW;AACb,MAAwB;AAET,EADQrD,EAAQF,CAAG,EACnB,QAAQ,CAACwD,MAAc;AAC5B,UAAAC,IAAaD,EAAU,MAAMD,CAAQ,GACrCG,IAAMD,EAAW,QACjBE,IAAUF,EAAWC,IAAM,CAAC,GAC5BhB,IAAUiB,MAAY,MAAM,MAAMrC,EAAKqC,CAAO;AAChD,QAAA,CAAC3C,EAAU0B,CAAO,EAAG;AAErB,IAACf,MAAOA,IAAQC,EAAS;AAC7B,UAAM3B,IAAOyD,IAAM,IAAI5D,EAAQe,GAAW4C,CAAU,IAAI,CAAC,GACnDG,IAA6C,CAAC;AACpD,IAAA5C,EAAU0B,CAAO,IAAI1B,EAAU0B,CAAO,EAAE,OAAO,CAACmB,MAAW;AAGnD,YAAAC,KADmBnE,IAASkE,EAAO,WAAWlE,IAAS,OAG3DkE,EAAO,UAAUlC,KACjBtB,EAAawD,EAAO,MAAM5D,CAAI;AAChC,aAAI6D,KAAUF,EAAe,KAAKC,EAAO,OAAO,GACzC,CAACC;AAAA,IAAA,CACT,GACDF,EAAe,QAAQ,CAACd,MAAYC,EAAeD,CAAO,CAAC;AAAA,EAAA,CAC5D;AACH;AAGA,SAASiB,EACPrE,GACAsE,GACArC,GACAmB,GACM;AACF,MAAAkB,EAAQ,YAAYlB;AACtB;AAEE,MAAAmB;AAGJ,MAAID,EAAQ,UAAUrC,KAASqC,EAAQ,UAAU,OAAO;AAErC,IAAAC,IAAAD,EAAQ,KAAK,SAAS;AAEvC,eAAWE,KAAKnD;AACd,MAAI,OAAO,UAAU,eAAe,KAAKA,GAAOmD,CAAC,MAE5C,CAACnD,EAAMmD,CAAC,KAAKF,EAAQ,KAAK,QAAQ,CAACE,CAAC,IAAI,MACxCnD,EAAMmD,CAAC,KAAKF,EAAQ,KAAK,QAAQ,CAACE,CAAC,MAAM,QAEzBD,IAAA;AAOpB,KAAAD,EAAQ,KAAK,WAAW,KACvB,CAACjD,EAAM,EAAE,KACT,CAACA,EAAM,EAAE,KACT,CAACA,EAAM,EAAE,KACT,CAACA,EAAM,EAAE,KACXkD,KACAD,EAAQ,aAAa,SAErBA,EAAQ,OAAO,CAAC,GAChBA,EAAQ,OAAOA,EAAQ,KAAK,OAAO9C,CAAS,GACxC8C,EAAQ,OAAOtE,GAAOsE,CAAO,MAAM,OACjCtE,EAAM,iBAAgBA,EAAM,eAAe,IACzCA,EAAc,cAAc,IAC9BA,EAAM,mBAAiBA,EAAM,gBAAgB,GAC5CA,EAAc,iBAAeA,EAAc,eAAe;AAAA,EAEnE;AAEJ;AAGA,SAASyE,EAEPzE,GACAoD,GACM;AACA,QAAAsB,IAAWpD,EAAU,GAAG;AAC9B,MAAIhB,IAAMN,EAAM,WAAWA,EAAM,SAAUA,EAAc;AAIzD,MAAIA,EAAM,MAAM;AACd,UAAM2E,IAAU;AAAA,MACd,MAAM;AAAA,MACN,MAAM;AAAA,MACN,MAAM;AAAA,MACN,MAAM;AAAA,MACN,MAAM;AAAA,MACN,MAAM;AAAA,MACN,MAAM;AAAA,MACN,MAAM;AAAA,MACN,MAAM;AAAA,MACN,MAAM;AAAA,MACN,MAAM;AAAA,MACN,MAAM;AAAA,MACN,MAAM;AAAA,MACN,MAAM;AAAA,MACN,MAAM;AAAA,MACN,MAAM;AAAA,MACN,MAAM;AAAA,MACN,MAAM;AAAA,MACN,MAAM;AAAA,MACN,MAAM;AAAA,MACN,MAAM;AAAA,MACN,MAAM;AAAA,MACN,MAAM;AAAA,MACN,MAAM;AAAA,MACN,MAAM;AAAA,MACN,MAAM;AAAA,IACR;AACI,IAAAA,EAAQ3E,EAAM,IAA4B,MACtCM,IAAAqE,EAAQ3E,EAAM,IAA4B;AAAA,EAClD;AAcF,MALIA,EAAM,OAAOA,EAAM,IAAI,kBAAkB,cAKzC,EADcuD,EAAgB,UAAUb,GAC9B,KAAK,MAAM1C,CAAK,EAAG;AAiCjC,OA7BIM,MAAQ,MAAMA,MAAQ,SAAWA,IAAA,KAQjCkB,EAAU,QAAQlB,CAAG,MAAM,MAAMA,MAAQ,OAAekB,EAAA,KAAKlB,CAAG,GAKpE,CAAC,WAAW,WAAW,UAAU,UAAU,EAAE,QAAQ,CAACsE,MAAY;AAC1D,UAAAC,IAAUzD,EAAoBwD,CAAO;AAC3C,IAAK5E,EAAc4E,CAAO,KAAKpD,EAAU,QAAQqD,CAAM,MAAM,KAC3DrD,EAAU,KAAKqD,CAAM,IACZ,CAAE7E,EAAc4E,CAAO,KAAKpD,EAAU,QAAQqD,CAAM,IAAI,KACjErD,EAAU,OAAOA,EAAU,QAAQqD,CAAM,GAAG,CAAC,IACpCD,MAAY,aAAc5E,EAAc4E,CAAO,MAIxDpD,IAAYA,EAAU,OAAO,CAACD,MAAMA,KAAKH,KAAeG,MAAMjB,CAAG;AAAA,EACnE,CACD,GAIGA,KAAOe,GAAO;AAChB,IAAAA,EAAMf,CAAG,IAAI;AAEb,eAAWiB,KAAKJ;AACd,UAAI,OAAO,UAAU,eAAe,KAAKA,GAAWI,CAAC,GAAG;AACtD,cAAMuD,IAAY1D,EAAoBD,EAAUI,CAAC,CAAC;AACjD,QAAAgC,EAAgBhC,CAAC,IAAKvB,EAAc8E,CAAQ;AAAA,MAAA;AAIjD,QAAI,CAACJ,EAAU;AAAA,EAAA;AAIjB,aAAWK,KAAK1D;AACd,IAAI,OAAO,UAAU,eAAe,KAAKA,GAAO0D,CAAC,MAC/C1D,EAAM0D,CAAC,IAAK/E,EAAeoB,EAAoB2D,CAAC,CAAC;AAUnD,EAAA/E,EAAM,oBACN,EAAEA,EAAM,UAAU,CAACA,EAAM,YACzBA,EAAM,iBAAiB,UAAU,MAE7BwB,EAAU,QAAQ,EAAE,MAAM,MAC5BA,EAAU,KAAK,EAAE,GAGfA,EAAU,QAAQ,EAAE,MAAM,MAC5BA,EAAU,KAAK,EAAE,GAGnBH,EAAM,EAAE,IAAI,IACZA,EAAM,EAAE,IAAI;AAId,QAAMY,IAAQC,EAAS;AAEvB,MAAIwC;AACF,aAASzD,IAAI,GAAGA,IAAIyD,EAAS,QAAQzD;AACnC,MACEyD,EAASzD,CAAC,EAAE,UAAUgB,MACpBjC,EAAM,SAAS,aAAa0E,EAASzD,CAAC,EAAE,WACvCjB,EAAM,SAAS,WAAW0E,EAASzD,CAAC,EAAE,UAEzCoD,EAAarE,GAAO0E,EAASzD,CAAC,GAAGgB,GAAOmB,CAAO;AAKjD,MAAA,EAAE9C,KAAOgB,GAAY;AAEnB,QAAA0D,IAAa1D,EAAUhB,CAAG,GAC1B2E,IAASD,EAAW;AAC1B,WAAS/D,IAAI,GAAGA,IAAIgE,GAAQhE;AAC1B,SACGjB,EAAM,SAAS,aAAagF,EAAW/D,CAAC,EAAE,WAC1CjB,EAAM,SAAS,WAAWgF,EAAW/D,CAAC,EAAE,UAErC+D,EAAW/D,CAAC,EAAE,KAAK;AACf,YAAAkD,IAASa,EAAW/D,CAAC,GACrB,EAAE,UAAA4C,MAAaM,GACfe,IAAcf,EAAO,IAAI,MAAMN,CAAQ,GACvCsB,IAA6B,CAAC;AACpC,eAASC,IAAI,GAAGA,IAAIF,EAAY,QAAQE;AACtC,QAAAD,EAAiB,KAAKvD,EAAKsD,EAAYE,CAAC,CAAC,CAAC;AAExC,MAAAD,EAAiB,OAAO,KAAK,EAAE,MAAM3D,EAAU,KAAK,EAAE,KAAK,EAAE,KAElD6C,EAAArE,GAAOmE,GAAQlC,GAAOmB,CAAO;AAAA,IAC5C;AAIR;AAyCA,SAASG,EACPjD,GACA+E,GACApF,GACM;AACN,EAAAuB,IAAY,CAAC;AAEP,QAAAf,IAAOD,EAAQF,CAAG;AACxB,MAAIC,IAAiB,CAAC,GAElB0B,IAAgB,OAEhBmB,IAAkC,UAClCnC,IAAI,GACJqE,IAAQ,IACRC,IAAU,IACV1B,IAAW,KACX2B,IAAU,IAEVC,IAAS;AAQb,MALIxF,MAAW,UAAa,OAAOoF,KAAW,eACnCpF,IAAAoF,IAIP,OAAO,UAAU,SAAS,KAAKA,CAAM,MAAM,mBAAmB;AAChE,UAAMK,IAAOL;AACT,IAAAK,EAAK,UAAOzD,IAAQyD,EAAK,QACzBA,EAAK,YAAStC,IAAUsC,EAAK,UAC7BA,EAAK,UAAOJ,IAAQI,EAAK,QACzBA,EAAK,YAAY,WAAWH,IAAUG,EAAK,UAC3CA,EAAK,YAAY,WAAWF,IAAUE,EAAK,UAC3C,OAAOA,EAAK,YAAa,iBAAqBA,EAAK,WACnDA,EAAK,WAAW,OAAeD,IAAA;AAAA,EAAA;AAS9B,OANH,OAAOJ,KAAW,aAAkBpD,IAAAoD,IAGpCI,KAAejC,EAAAlD,GAAK2B,CAAK,GAGtBhB,IAAIR,EAAK,QAAQQ,KAAK;AAC3B,UAAM0E,IAAalF,EAAKQ,CAAC,EAAE,MAAM4C,CAAQ;AACzC,IAAAtD,IAAO,CAAC,GAGJoF,EAAW,SAAS,MAAUpF,IAAAH,EAAQe,GAAWwE,CAAU;AAG/D,QAAIC,IAA4BD,EAAWA,EAAW,SAAS,CAAC;AAChE,IAAAC,IAAWA,MAAa,MAAM,MAAMhE,EAAKgE,CAAQ,GAG3CA,KAAYtE,MAAsBA,EAAAsE,CAAQ,IAAI,CAAC,IAE3CtE,EAAAsE,CAAQ,EAAE,KAAK;AAAA,MACvB,OAAAN;AAAA,MACA,SAAAC;AAAA,MACA,OAAAtD;AAAA,MACA,MAAA1B;AAAA,MACA,UAAUE,EAAKQ,CAAC;AAAA,MAChB,QAAAhB;AAAA,MACA,KAAKQ,EAAKQ,CAAC;AAAA,MACX,UAAA4C;AAAA,MACA,SAAAT;AAAA,IAAA,CACD;AAAA,EAAA;AAGH,MAAI,OAAOA,KAAY,eAAe,OAAO,UAAW,aAAa;AACnE,QAAI,CAACzB,EAAgB,IAAIyB,CAAO,GAAG;AACjC,YAAMyC,IAAkB,CAAC7F,IAAgB,OAAe,UACtDyE,EAASzE,GAAwBoD,CAAO,GACpC0C,IAAe,CAAC9F,IAAgB,OAAe,UAAU;AAC7D,QAAAyE,EAASzE,GAAwBoD,CAAO,GACxCE,EAActD,CAAsB;AAAA,MACtC;AACA,MAAA2B,EAAgB,IAAIyB,GAAS,EAAE,iBAAAyC,GAAiB,cAAAC,GAAc,SAAAN,GAAS,GAC9D1F,EAAAsD,GAAS,WAAWyC,GAAiBL,CAAO,GAC5C1F,EAAAsD,GAAS,SAAS0C,GAAcN,CAAO;AAAA,IAAA;AAGlD,QAAI,CAAC/D,GAAiB;AACpB,YAAMsE,IAAW,MAAM;AACrB,QAAAvE,IAAY,CAAC;AAAA,MACf;AACkB,MAAAC,IAAA,EAAE,UAAAsE,GAAU,SAAAP,EAAQ,GAC7B1F,EAAA,QAAQ,SAASiG,GAAUP,CAAO;AAAA,IAAA;AAAA,EAC7C;AAEJ;AAEA,SAASQ,EAAQxD,GAAkBP,IAAgB,OAAa;AAC9D,SAAO,KAAKX,CAAS,EAAE,QAAQ,CAAChB,MAAQ;AAI7B,IAHQgB,EAAUhB,CAAG,EAAE;AAAA,MAC9B,CAAC2F,MAASA,EAAK,UAAUhE,KAASgE,EAAK,aAAazD;AAAA,IACtD,EACS,QAAQ,CAAC0D,MAAS;AACrB,MAAAA,KAAQA,EAAK,UACVA,EAAA,OAAO,CAAC,GAAoBA,CAAI;AAAA,IACvC,CACD;AAAA,EAAA,CACF;AACH;AAGA,SAAS7C,EAAeD,GAA8C;AACpE,QAAM+C,IAAS,OAAO,OAAO7E,CAAS,EAAE,KAAK;AAGzC,MAFc6E,EAAO,UAAU,CAAC,EAAE,SAASC,EAAA,MAASA,MAAOhD,CAAO,IAEtD,KAAKA,GAAS;AACtB,UAAA,EAAE,iBAAAyC,GAAiB,cAAAC,GAAc,SAAAN,EAAA,IACrC7D,EAAgB,IAAIyB,CAAO,KAAM,CAAC;AACpC,IAAIyC,KAAmBC,MACT3F,EAAAiD,GAAS,SAAS0C,GAAcN,CAAO,GACvCrF,EAAAiD,GAAS,WAAWyC,GAAiBL,CAAO,GACxD7D,EAAgB,OAAOyB,CAAO;AAAA,EAChC;AAGF,OAAI+C,EAAO,UAAU,KAAKxE,EAAgB,QAAQ,OAE9B,MAAM,KAAKA,EAAgB,MAAM,EACzC,QAAQ,CAACyE,MAAO;AAClB,UAAA,EAAE,iBAAAP,GAAiB,cAAAC,GAAc,SAAAN,EAAA,IACrC7D,EAAgB,IAAIyE,CAAE,KAAM,CAAC;AAC/B,IAAIP,KAAmBC,MACT3F,EAAAiG,GAAI,SAASN,GAAcN,CAAO,GAClCrF,EAAAiG,GAAI,WAAWP,GAAiBL,CAAO,GACnD7D,EAAgB,OAAOyE,CAAE;AAAA,EAC3B,CACD,GAEDzE,EAAgB,MAAM,GAEf,OAAA,KAAKL,CAAS,EAAE,QAAQ,CAAChB,MAAQ,OAAOgB,EAAUhB,CAAG,CAAC,GAEzDmB,IAAiB;AACb,UAAA,EAAE,UAAAsE,GAAU,SAAAP,EAAA,IAAY/D;AAClB,IAAAtB,EAAA,QAAQ,SAAS4F,GAAUP,CAAO,GAC5B/D,IAAA;AAAA,EAAA;AAGxB;AAEA,MAAM4E,IAAO;AAAA,EACX,qBAAAjE;AAAA,EACA,UAAAJ;AAAA,EACA,UAAAE;AAAA,EACA,aAAAe;AAAA,EACA,oBAAAd;AAAA,EACA,gBAAAG;AAAA,EACA,WAAAS;AAAA,EACA,QAAAL;AAAA,EACA,SAAAsD;AAAA,EACA,QAAAxC;AAAA,EACA,QAAQtC;AAAA,EACR,UAAUC;AAAA,EACV,aAAAC;AACF;AAEA,WAAWgE,KAAKiB;AACd,EAAI,OAAO,UAAU,eAAe,KAAKA,GAAMjB,CAAC,MAC7C7B,EAAgB6B,CAAC,IAAKiB,EAAajB,CAAC;AAIzC,IAAI,OAAO,UAAW,aAAa;AACjC,QAAMkB,IAAY,OAAe;AAChC,EAAA/C,EAA6B,aAAa,CAACgD,OACtCA,KAAS,OAAe,YAAYhD,MACrC,OAAe,UAAU+C,IAErB/C,IAER,OAAe,UAAUA;AAC5B;"}