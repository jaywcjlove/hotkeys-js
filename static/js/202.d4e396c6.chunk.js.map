{"version":3,"sources":["../node_modules/prismjs/components/prism-js-templates.js"],"names":["Prism","templateString","languages","javascript","templateLiteralPattern","pattern","source","interpolationObject","inside","interpolationPunctuationObject","interpolationPattern","createTemplate","language","tag","RegExp","lookbehind","greedy","alias","getPlaceholder","counter","toUpperCase","tokenizeWithHooks","code","grammar","env","hooks","run","tokens","tokenize","tokenizeInterpolationExpression","expression","tempGrammar","length","args","push","apply","splice","Token","tokenizeEmbedded","_tokens","placeholderCounter","placeholderMap","embeddedTokens","map","token","placeholder","interpolationExpression","content","indexOf","join","placeholders","Object","keys","walkTokens","i","s","index","before","substring","middle","after","replacement","afterTokens","concat","Array","isArray","filter","Boolean","supportedLanguages","stringContent","value","add","findTemplateStrings","l","type","embedded"],"mappings":"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","file":"static/js/202.d4e396c6.chunk.js","sourcesContent":["(function (Prism) {\n  var templateString = Prism.languages.javascript['template-string']; // see the pattern in prism-javascript.js\n\n  var templateLiteralPattern = templateString.pattern.source;\n  var interpolationObject = templateString.inside['interpolation'];\n  var interpolationPunctuationObject = interpolationObject.inside['interpolation-punctuation'];\n  var interpolationPattern = interpolationObject.pattern.source;\n  /**\n   * Creates a new pattern to match a template string with a special tag.\n   *\n   * This will return `undefined` if there is no grammar with the given language id.\n   *\n   * @param {string} language The language id of the embedded language. E.g. `markdown`.\n   * @param {string} tag The regex pattern to match the tag.\n   * @returns {object | undefined}\n   * @example\n   * createTemplate('css', /\\bcss/.source);\n   */\n\n  function createTemplate(language, tag) {\n    if (!Prism.languages[language]) {\n      return undefined;\n    }\n\n    return {\n      pattern: RegExp('((?:' + tag + ')\\\\s*)' + templateLiteralPattern),\n      lookbehind: true,\n      greedy: true,\n      inside: {\n        'template-punctuation': {\n          pattern: /^`|`$/,\n          alias: 'string'\n        },\n        'embedded-code': {\n          pattern: /[\\s\\S]+/,\n          alias: language\n        }\n      }\n    };\n  }\n\n  Prism.languages.javascript['template-string'] = [// styled-jsx:\n  //   css`a { color: #25F; }`\n  // styled-components:\n  //   styled.h1`color: red;`\n  createTemplate('css', /\\b(?:styled(?:\\([^)]*\\))?(?:\\s*\\.\\s*\\w+(?:\\([^)]*\\))*)*|css(?:\\s*\\.\\s*(?:global|resolve))?|createGlobalStyle|keyframes)/.source), // html`<p></p>`\n  // div.innerHTML = `<p></p>`\n  createTemplate('html', /\\bhtml|\\.\\s*(?:inner|outer)HTML\\s*\\+?=/.source), // svg`<path fill=\"#fff\" d=\"M55.37 ...\"/>`\n  createTemplate('svg', /\\bsvg/.source), // md`# h1`, markdown`## h2`\n  createTemplate('markdown', /\\b(?:md|markdown)/.source), // gql`...`, graphql`...`, graphql.experimental`...`\n  createTemplate('graphql', /\\b(?:gql|graphql(?:\\s*\\.\\s*experimental)?)/.source), // vanilla template string\n  templateString].filter(Boolean);\n  /**\n   * Returns a specific placeholder literal for the given language.\n   *\n   * @param {number} counter\n   * @param {string} language\n   * @returns {string}\n   */\n\n  function getPlaceholder(counter, language) {\n    return '___' + language.toUpperCase() + '_' + counter + '___';\n  }\n  /**\n   * Returns the tokens of `Prism.tokenize` but also runs the `before-tokenize` and `after-tokenize` hooks.\n   *\n   * @param {string} code\n   * @param {any} grammar\n   * @param {string} language\n   * @returns {(string|Token)[]}\n   */\n\n\n  function tokenizeWithHooks(code, grammar, language) {\n    var env = {\n      code: code,\n      grammar: grammar,\n      language: language\n    };\n    Prism.hooks.run('before-tokenize', env);\n    env.tokens = Prism.tokenize(env.code, env.grammar);\n    Prism.hooks.run('after-tokenize', env);\n    return env.tokens;\n  }\n  /**\n   * Returns the token of the given JavaScript interpolation expression.\n   *\n   * @param {string} expression The code of the expression. E.g. `\"${42}\"`\n   * @returns {Token}\n   */\n\n\n  function tokenizeInterpolationExpression(expression) {\n    var tempGrammar = {};\n    tempGrammar['interpolation-punctuation'] = interpolationPunctuationObject;\n    /** @type {Array} */\n\n    var tokens = Prism.tokenize(expression, tempGrammar);\n\n    if (tokens.length === 3) {\n      /**\n       * The token array will look like this\n       * [\n       *     [\"interpolation-punctuation\", \"${\"]\n       *     \"...\" // JavaScript expression of the interpolation\n       *     [\"interpolation-punctuation\", \"}\"]\n       * ]\n       */\n      var args = [1, 1];\n      args.push.apply(args, tokenizeWithHooks(tokens[1], Prism.languages.javascript, 'javascript'));\n      tokens.splice.apply(tokens, args);\n    }\n\n    return new Prism.Token('interpolation', tokens, interpolationObject.alias, expression);\n  }\n  /**\n   * Tokenizes the given code with support for JavaScript interpolation expressions mixed in.\n   *\n   * This function has 3 phases:\n   *\n   * 1. Replace all JavaScript interpolation expression with a placeholder.\n   *    The placeholder will have the syntax of a identify of the target language.\n   * 2. Tokenize the code with placeholders.\n   * 3. Tokenize the interpolation expressions and re-insert them into the tokenize code.\n   *    The insertion only works if a placeholder hasn't been \"ripped apart\" meaning that the placeholder has been\n   *    tokenized as two tokens by the grammar of the embedded language.\n   *\n   * @param {string} code\n   * @param {object} grammar\n   * @param {string} language\n   * @returns {Token}\n   */\n\n\n  function tokenizeEmbedded(code, grammar, language) {\n    // 1. First filter out all interpolations\n    // because they might be escaped, we need a lookbehind, so we use Prism\n\n    /** @type {(Token|string)[]} */\n    var _tokens = Prism.tokenize(code, {\n      'interpolation': {\n        pattern: RegExp(interpolationPattern),\n        lookbehind: true\n      }\n    }); // replace all interpolations with a placeholder which is not in the code already\n\n\n    var placeholderCounter = 0;\n    /** @type {Object<string, string>} */\n\n    var placeholderMap = {};\n\n    var embeddedCode = _tokens.map(function (token) {\n      if (typeof token === 'string') {\n        return token;\n      } else {\n        var interpolationExpression = token.content;\n        var placeholder;\n\n        while (code.indexOf(placeholder = getPlaceholder(placeholderCounter++, language)) !== -1) {}\n\n        placeholderMap[placeholder] = interpolationExpression;\n        return placeholder;\n      }\n    }).join(''); // 2. Tokenize the embedded code\n\n\n    var embeddedTokens = tokenizeWithHooks(embeddedCode, grammar, language); // 3. Re-insert the interpolation\n\n    var placeholders = Object.keys(placeholderMap);\n    placeholderCounter = 0;\n    /**\n     *\n     * @param {(Token|string)[]} tokens\n     * @returns {void}\n     */\n\n    function walkTokens(tokens) {\n      for (var i = 0; i < tokens.length; i++) {\n        if (placeholderCounter >= placeholders.length) {\n          return;\n        }\n\n        var token = tokens[i];\n\n        if (typeof token === 'string' || typeof token.content === 'string') {\n          var placeholder = placeholders[placeholderCounter];\n          var s = typeof token === 'string' ? token :\n          /** @type {string} */\n          token.content;\n          var index = s.indexOf(placeholder);\n\n          if (index !== -1) {\n            ++placeholderCounter;\n            var before = s.substring(0, index);\n            var middle = tokenizeInterpolationExpression(placeholderMap[placeholder]);\n            var after = s.substring(index + placeholder.length);\n            var replacement = [];\n\n            if (before) {\n              replacement.push(before);\n            }\n\n            replacement.push(middle);\n\n            if (after) {\n              var afterTokens = [after];\n              walkTokens(afterTokens);\n              replacement.push.apply(replacement, afterTokens);\n            }\n\n            if (typeof token === 'string') {\n              tokens.splice.apply(tokens, [i, 1].concat(replacement));\n              i += replacement.length - 1;\n            } else {\n              token.content = replacement;\n            }\n          }\n        } else {\n          var content = token.content;\n\n          if (Array.isArray(content)) {\n            walkTokens(content);\n          } else {\n            walkTokens([content]);\n          }\n        }\n      }\n    }\n\n    walkTokens(embeddedTokens);\n    return new Prism.Token(language, embeddedTokens, 'language-' + language, code);\n  }\n  /**\n   * The languages for which JS templating will handle tagged template literals.\n   *\n   * JS templating isn't active for only JavaScript but also related languages like TypeScript, JSX, and TSX.\n   */\n\n\n  var supportedLanguages = {\n    'javascript': true,\n    'js': true,\n    'typescript': true,\n    'ts': true,\n    'jsx': true,\n    'tsx': true\n  };\n  Prism.hooks.add('after-tokenize', function (env) {\n    if (!(env.language in supportedLanguages)) {\n      return;\n    }\n    /**\n     * Finds and tokenizes all template strings with an embedded languages.\n     *\n     * @param {(Token | string)[]} tokens\n     * @returns {void}\n     */\n\n\n    function findTemplateStrings(tokens) {\n      for (var i = 0, l = tokens.length; i < l; i++) {\n        var token = tokens[i];\n\n        if (typeof token === 'string') {\n          continue;\n        }\n\n        var content = token.content;\n\n        if (!Array.isArray(content)) {\n          if (typeof content !== 'string') {\n            findTemplateStrings([content]);\n          }\n\n          continue;\n        }\n\n        if (token.type === 'template-string') {\n          /**\n           * A JavaScript template-string token will look like this:\n           *\n           * [\"template-string\", [\n           *     [\"template-punctuation\", \"`\"],\n           *     (\n           *         An array of \"string\" and \"interpolation\" tokens. This is the simple string case.\n           *         or\n           *         [\"embedded-code\", \"...\"] This is the token containing the embedded code.\n           *                                  It also has an alias which is the language of the embedded code.\n           *     ),\n           *     [\"template-punctuation\", \"`\"]\n           * ]]\n           */\n          var embedded = content[1];\n\n          if (content.length === 3 && typeof embedded !== 'string' && embedded.type === 'embedded-code') {\n            // get string content\n            var code = stringContent(embedded);\n            var alias = embedded.alias;\n            var language = Array.isArray(alias) ? alias[0] : alias;\n            var grammar = Prism.languages[language];\n\n            if (!grammar) {\n              // the embedded language isn't registered.\n              continue;\n            }\n\n            content[1] = tokenizeEmbedded(code, grammar, language);\n          }\n        } else {\n          findTemplateStrings(content);\n        }\n      }\n    }\n\n    findTemplateStrings(env.tokens);\n  });\n  /**\n   * Returns the string content of a token or token stream.\n   *\n   * @param {string | Token | (string | Token)[]} value\n   * @returns {string}\n   */\n\n  function stringContent(value) {\n    if (typeof value === 'string') {\n      return value;\n    } else if (Array.isArray(value)) {\n      return value.map(stringContent).join('');\n    } else {\n      return stringContent(value.content);\n    }\n  }\n})(Prism);"],"sourceRoot":""}