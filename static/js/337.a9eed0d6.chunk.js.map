{"version":3,"sources":["../node_modules/prismjs/components/prism-racket.js"],"names":["Prism","languages","racket","extend","pattern","lookbehind","DFS","key","value","util","type","source","replace","m","g1","g2","this","RegExp","flags","insertBefore","greedy","alias","rkt"],"mappings":"mGAAAA,MAAMC,UAAUC,OAASF,MAAMC,UAAUE,OAAO,SAAU,CACxD,mBAAoB,CAGlBC,QAAS,2BACTC,YAAY,KAgBhBL,MAAMC,UAAUK,IAAIN,MAAMC,UAAUC,QAAQ,SAAUK,EAAKC,GACzD,GAA+B,WAA3BR,MAAMS,KAAKC,KAAKF,GAAqB,CACvC,IAAIG,EAASH,EAAMG,OAAOC,QAAQ,oCAAoC,SAAUC,EAAGC,EAAIC,GACrF,GAAID,EAAI,CACN,GAAW,MAAPA,EAEF,MAAO,OAGT,GAAW,MAAPA,EAEF,MAAO,SAIX,OAAIC,GACoB,MAATF,EAAE,GAAa,KAAO,KACnBE,EAAGH,QAAQ,eAAe,SAAUC,EAAGC,GACrD,MAAU,MAAND,GAAoB,MAAPC,EAER,KAGC,MAAND,GAAoB,MAAPC,EAER,OAGFD,KACJ,IAGAA,KAETG,KAAKT,GAAOU,OAAON,EAAQH,EAAMU,WAGrClB,MAAMC,UAAUkB,aAAa,SAAU,SAAU,CAC/C,KAAQ,CACNf,QAAS,YACTgB,QAAQ,EACRC,MAAO,aAGXrB,MAAMC,UAAUqB,IAAMtB,MAAMC,UAAUC","file":"static/js/337.a9eed0d6.chunk.js","sourcesContent":["Prism.languages.racket = Prism.languages.extend('scheme', {\n  'lambda-parameter': {\n    // the racket lambda syntax is a lot more complex, so we won't even attempt to capture it.\n    // this will just prevent false positives of the `function` pattern\n    pattern: /(\\(lambda\\s+\\()[^()'\\s]+/,\n    lookbehind: true\n  }\n}); // Add brackets to racket\n// The basic idea here is to go through all pattens of Scheme and replace all occurrences of \"(\" with the union of \"(\"\n// and \"[\"; Similar for \")\". This is a bit tricky because \"(\" can be escaped or inside a character set. Both cases\n// have to be handled differently and, of course, we don't want to destroy groups, so we can only replace literal \"(\"\n// and \")\".\n// To do this, we use a regular expression which will parse any JS regular expression. It works because regexes are\n// matches from left to right and already matched text cannot be matched again. We use this to first capture all\n// escaped characters (not really, we don't get escape sequences but we don't need them). Because we already captured\n// all escaped characters, we know that any \"[\" character is the start of a character set, so we match that character\n// set whole.\n// With the regex parsed, we only have to replace all escaped \"(\" (they cannot be unescaped outside of character sets)\n// with /[([]/ and replace all \"(\" inside character sets.\n// Note: This method does not work for \"(\" that are escaped like this /\\x28/ or this /\\u0028/.\n\nPrism.languages.DFS(Prism.languages.racket, function (key, value) {\n  if (Prism.util.type(value) === 'RegExp') {\n    var source = value.source.replace(/\\\\(.)|\\[\\^?((?:\\\\.|[^\\\\\\]])*)\\]/g, function (m, g1, g2) {\n      if (g1) {\n        if (g1 === '(') {\n          // replace all '(' characters outside character sets\n          return '[([]';\n        }\n\n        if (g1 === ')') {\n          // replace all ')' characters outside character sets\n          return '[)\\\\]]';\n        }\n      }\n\n      if (g2) {\n        var prefix = m[1] === '^' ? '[^' : '[';\n        return prefix + g2.replace(/\\\\(.)|[()]/g, function (m, g1) {\n          if (m === '(' || g1 === '(') {\n            // replace all '(' characters inside character sets\n            return '([';\n          }\n\n          if (m === ')' || g1 === ')') {\n            // replace all ')' characters inside character sets\n            return ')\\\\]';\n          }\n\n          return m;\n        }) + ']';\n      }\n\n      return m;\n    });\n    this[key] = RegExp(source, value.flags);\n  }\n});\nPrism.languages.insertBefore('racket', 'string', {\n  'lang': {\n    pattern: /^#lang.+/m,\n    greedy: true,\n    alias: 'keyword'\n  }\n});\nPrism.languages.rkt = Prism.languages.racket;"],"sourceRoot":""}