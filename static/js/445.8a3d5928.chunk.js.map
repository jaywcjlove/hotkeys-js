{"version":3,"sources":["../node_modules/prismjs/components/prism-xquery.js"],"names":["Prism","languages","xquery","extend","pattern","greedy","alias","lookbehind","tag","inside","stringifyToken","token","content","map","join","walkTokens","tokens","openedTags","i","length","notTagNorBrace","type","tagName","pop","push","openedBraces","plainText","splice","test","Token","hooks","add","env","language"],"mappings":"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","file":"static/js/445.8a3d5928.chunk.js","sourcesContent":["(function (Prism) {\n\n\tPrism.languages.xquery = Prism.languages.extend('markup', {\n\t\t'xquery-comment': {\n\t\t\tpattern: /\\(:[\\s\\S]*?:\\)/,\n\t\t\tgreedy: true,\n\t\t\talias: \"comment\"\n\t\t},\n\t\t'string': {\n\t\t\tpattern: /([\"'])(?:\\1\\1|(?!\\1)[\\s\\S])*\\1/,\n\t\t\tgreedy: true\n\t\t},\n\t\t'extension': {\n\t\t\tpattern: /\\(#.+?#\\)/,\n\t\t\talias: 'symbol'\n\t\t},\n\t\t'variable': /\\$[\\w-:]+/,\n\t\t'axis': {\n\t\t\tpattern: /(^|[^-])(?:ancestor(?:-or-self)?|attribute|child|descendant(?:-or-self)?|following(?:-sibling)?|parent|preceding(?:-sibling)?|self)(?=::)/,\n\t\t\tlookbehind: true,\n\t\t\talias: 'operator'\n\t\t},\n\t\t'keyword-operator': {\n\t\t\tpattern: /(^|[^:-])\\b(?:and|castable as|div|eq|except|ge|gt|idiv|instance of|intersect|is|le|lt|mod|ne|or|union)\\b(?=$|[^:-])/,\n\t\t\tlookbehind: true,\n\t\t\talias: 'operator'\n\t\t},\n\t\t'keyword': {\n\t\t\tpattern: /(^|[^:-])\\b(?:as|ascending|at|base-uri|boundary-space|case|cast as|collation|construction|copy-namespaces|declare|default|descending|else|empty (?:greatest|least)|encoding|every|external|for|function|if|import|in|inherit|lax|let|map|module|namespace|no-inherit|no-preserve|option|order(?: by|ed|ing)?|preserve|return|satisfies|schema|some|stable|strict|strip|then|to|treat as|typeswitch|unordered|validate|variable|version|where|xquery)\\b(?=$|[^:-])/,\n\t\t\tlookbehind: true\n\t\t},\n\t\t'function': /[\\w-]+(?::[\\w-]+)*(?=\\s*\\()/,\n\t\t'xquery-element': {\n\t\t\tpattern: /(element\\s+)[\\w-]+(?::[\\w-]+)*/,\n\t\t\tlookbehind: true,\n\t\t\talias: 'tag'\n\t\t},\n\t\t'xquery-attribute': {\n\t\t\tpattern: /(attribute\\s+)[\\w-]+(?::[\\w-]+)*/,\n\t\t\tlookbehind: true,\n\t\t\talias: 'attr-name'\n\t\t},\n\t\t'builtin': {\n\t\t\tpattern: /(^|[^:-])\\b(?:attribute|comment|document|element|processing-instruction|text|xs:(?:anyAtomicType|anyType|anyURI|base64Binary|boolean|byte|date|dateTime|dayTimeDuration|decimal|double|duration|ENTITIES|ENTITY|float|gDay|gMonth|gMonthDay|gYear|gYearMonth|hexBinary|ID|IDREFS?|int|integer|language|long|Name|NCName|negativeInteger|NMTOKENS?|nonNegativeInteger|nonPositiveInteger|normalizedString|NOTATION|positiveInteger|QName|short|string|time|token|unsigned(?:Byte|Int|Long|Short)|untyped(?:Atomic)?|yearMonthDuration))\\b(?=$|[^:-])/,\n\t\t\tlookbehind: true\n\t\t},\n\t\t'number': /\\b\\d+(?:\\.\\d+)?(?:E[+-]?\\d+)?/,\n\t\t'operator': [\n\t\t\t/[+*=?|@]|\\.\\.?|:=|!=|<[=<]?|>[=>]?/,\n\t\t\t{\n\t\t\t\tpattern: /(\\s)-(?=\\s)/,\n\t\t\t\tlookbehind: true\n\t\t\t}\n\t\t],\n\t\t'punctuation': /[[\\](){},;:/]/\n\t});\n\n\tPrism.languages.xquery.tag.pattern = /<\\/?(?!\\d)[^\\s>\\/=$<%]+(?:\\s+[^\\s>\\/=]+(?:=(?:(\"|')(?:\\\\[\\s\\S]|{(?!{)(?:{(?:{[^{}]*}|[^{}])*}|[^{}])+}|(?!\\1)[^\\\\])*\\1|[^\\s'\">=]+))?)*\\s*\\/?>/i;\n\tPrism.languages.xquery['tag'].inside['attr-value'].pattern = /=(?:(\"|')(?:\\\\[\\s\\S]|{(?!{)(?:{(?:{[^{}]*}|[^{}])*}|[^{}])+}|(?!\\1)[^\\\\])*\\1|[^\\s'\">=]+)/i;\n\tPrism.languages.xquery['tag'].inside['attr-value'].inside['punctuation'] = /^=\"|\"$/;\n\tPrism.languages.xquery['tag'].inside['attr-value'].inside['expression'] = {\n\t\t// Allow for two levels of nesting\n\t\tpattern: /{(?!{)(?:{(?:{[^{}]*}|[^{}])*}|[^{}])+}/,\n\t\tinside: Prism.languages.xquery,\n\t\talias: 'language-xquery'\n\t};\n\n\t// The following will handle plain text inside tags\n\tvar stringifyToken = function (token) {\n\t\tif (typeof token === 'string') {\n\t\t\treturn token;\n\t\t}\n\t\tif (typeof token.content === 'string') {\n\t\t\treturn token.content;\n\t\t}\n\t\treturn token.content.map(stringifyToken).join('');\n\t};\n\n\tvar walkTokens = function (tokens) {\n\t\tvar openedTags = [];\n\t\tfor (var i = 0; i < tokens.length; i++) {\n\t\t\tvar token = tokens[i];\n\t\t\tvar notTagNorBrace = false;\n\n\t\t\tif (typeof token !== 'string') {\n\t\t\t\tif (token.type === 'tag' && token.content[0] && token.content[0].type === 'tag') {\n\t\t\t\t\t// We found a tag, now find its kind\n\n\t\t\t\t\tif (token.content[0].content[0].content === '</') {\n\t\t\t\t\t\t// Closing tag\n\t\t\t\t\t\tif (openedTags.length > 0 && openedTags[openedTags.length - 1].tagName === stringifyToken(token.content[0].content[1])) {\n\t\t\t\t\t\t\t// Pop matching opening tag\n\t\t\t\t\t\t\topenedTags.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (token.content[token.content.length - 1].content === '/>') {\n\t\t\t\t\t\t\t// Autoclosed tag, ignore\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Opening tag\n\t\t\t\t\t\t\topenedTags.push({\n\t\t\t\t\t\t\t\ttagName: stringifyToken(token.content[0].content[1]),\n\t\t\t\t\t\t\t\topenedBraces: 0\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (\n\t\t\t\t\topenedTags.length > 0 && token.type === 'punctuation' && token.content === '{' &&\n\t\t\t\t\t// Ignore `{{`\n\t\t\t\t\t(!tokens[i + 1] || tokens[i + 1].type !== 'punctuation' || tokens[i + 1].content !== '{') &&\n\t\t\t\t\t(!tokens[i - 1] || tokens[i - 1].type !== 'plain-text' || tokens[i - 1].content !== '{')\n\t\t\t\t) {\n\t\t\t\t\t// Here we might have entered an XQuery expression inside a tag\n\t\t\t\t\topenedTags[openedTags.length - 1].openedBraces++;\n\n\t\t\t\t} else if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces > 0 && token.type === 'punctuation' && token.content === '}') {\n\n\t\t\t\t\t// Here we might have left an XQuery expression inside a tag\n\t\t\t\t\topenedTags[openedTags.length - 1].openedBraces--;\n\n\t\t\t\t} else if (token.type !== 'comment') {\n\t\t\t\t\tnotTagNorBrace = true\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (notTagNorBrace || typeof token === 'string') {\n\t\t\t\tif (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces === 0) {\n\t\t\t\t\t// Here we are inside a tag, and not inside an XQuery expression.\n\t\t\t\t\t// That's plain text: drop any tokens matched.\n\t\t\t\t\tvar plainText = stringifyToken(token);\n\n\t\t\t\t\t// And merge text with adjacent text\n\t\t\t\t\tif (i < tokens.length - 1 && (typeof tokens[i + 1] === 'string' || tokens[i + 1].type === 'plain-text')) {\n\t\t\t\t\t\tplainText += stringifyToken(tokens[i + 1]);\n\t\t\t\t\t\ttokens.splice(i + 1, 1);\n\t\t\t\t\t}\n\t\t\t\t\tif (i > 0 && (typeof tokens[i - 1] === 'string' || tokens[i - 1].type === 'plain-text')) {\n\t\t\t\t\t\tplainText = stringifyToken(tokens[i - 1]) + plainText;\n\t\t\t\t\t\ttokens.splice(i - 1, 1);\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (/^\\s+$/.test(plainText)) {\n\t\t\t\t\t\ttokens[i] = plainText;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttokens[i] = new Prism.Token('plain-text', plainText, null, plainText);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (token.content && typeof token.content !== 'string') {\n\t\t\t\twalkTokens(token.content);\n\t\t\t}\n\t\t}\n\t};\n\n\tPrism.hooks.add('after-tokenize', function (env) {\n\t\tif (env.language !== 'xquery') {\n\t\t\treturn;\n\t\t}\n\t\twalkTokens(env.tokens);\n\t});\n\n}(Prism));\n"],"sourceRoot":""}